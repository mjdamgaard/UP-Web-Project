
# A User-Programmable Web

*A prototype of this project is now available at [www.up-web.org](https://www.up-web.org)!*


  
## Serverless computing on a new level
    
The User-Programmable Web (UP Web) is an open-source web development
framework that takes the concept of
[serverless computing](https://en.wikipedia.org/wiki/Serverless_computing)
to the next level: Not only do applications scale automatically, they
scale without any cost to the developers. 

The cost of the resources that an app consumes is instead paid for by
the users of that app, who pay either by watching ads on the website on
which the app is hosted, or via subscription to the website.

Furthermore, the organization behind up-web.org will function as a
nonprofit, and its goal will be to maximize the benefit of the users of
the UP Web.  

All profits will thus go towards rewarding the open source developers of
the UP Web, along with content creators and other contributors.    



## Open source and free data portability

The fact that the UP Web is an open source project means that anyone is
free to set up their own versions of up-web.org, and to modify the
source code at will.

In fact, up-web.org encourages this kind of competition from other
service providers, and vows to
always try to make it as easy as possible for developers and users to
transfer their apps and data to other service providers.

So if anyone has complaints about how up-web.org functions, or how it
redistributes its profits to the contributors, they are completely free
to set up a competitor that aims to do things differently. 

And apart from allowing for free data portability,
up-web.org also vows to allow apps to communicate freely across different
service providers. This means that apps can potentially extend over
several service providers at once, and utilize all the different user
networks as one combined network.



## Easy to get started

It is easy get started making your first user-programmed app. On the
[Tutorials](https://www.up-web.org/tutorials)
page you will find a list of tutorials that will teach you how.


By the end of the first tutorial, you will have learned how to upload a simple
"Hello, World!" app. And the next couple of tutorials will teach you how
to style your apps, how to make them responsive, and how to
make them upload and download data from the database.

In fact, by the end of
[Tutorial 5](https://www.up-web.org/tutorials/server-modules),
you will already have learned how to make a little message app, where
you and other users can communicate, privately or publicly.

The development framework that is provided is a JS framework inspired by
[React](https://www.w3schools.com/react/default.asp).
So if you are already familiar with React, getting started will be
particularly easy. 

And once you have uploaded a new app or webpage, it will in theory stay
up forever, until you modify or delete it.

That is, unless your app breaks our terms of service, of
course, which involves adhering to the GDPR, as well as not trying to
scam other users, etc.



## User-uploaded code is run in a sandbox

All user-uploaded code is executed in a sandbox that prevents it from
accessing any unsafe features of JavaScript. This true both when the code
is executed client-side and when it is executed server-side.

Other users can therefore safely try out your new app prototypes,
without having to worry about their browser getting hacked. And you can
safely try out theirs as well.

Different apps are also assigned different parts of the database,
isolated from each other. And apps can only upload and download data
between each other when the creators allow it.



## From Web 2.0 to Web 3.0

The change from Web 1.0 to
[Web 2.0](https://en.wikipedia.org/wiki/Web_2.0)
meant the emergence of websites where the users are
responsible for the content shown on the sites to a large extent.

The structure and appearance of
these websites are still, however, a responsibility solely of the
owners of the websites, and the same is true for the algorithms that
they use.

The UP Web seeks to go one step further in this process by allowing the
users to help program the apps for the websites as well, and help
decide their appearance and their algorithms.

And in the same way that content creators are often rewarded monetarily
on Web 2.0 sites, so will the users that help create the apps and the
algorithms for the UP Web.

The rewards that these app-developing users receive ought to
reflect how much their contributions help increase the benefit of other
users. So for example, if you help create or improve a given app, and
that app ends up being used by a significant portion of the user base,
you will also receive a significant portion of the revenue of the UP Web
as a reward.



## Users can choose their own set of apps and algorithms

Since the mission of up-web.org is to maximize the benefit of its users,
there is no point in trying to force a particular set of apps and
algorithms on our user base. 

Instead we will give each individual user the freedom to choose for
themselves. And not only will they be free to choose which set of apps
they want to use, but also which version of each individual app to use.

We also strongly encourage our app-developing users to make it possible
for other users to change and adjust the algorithms of the apps.

Each user of up-web.org will thus start out with the most popular
set of apps and algorithms as the default choice. And if they want to,
they are then free to change this choice at any time.




## Reasons to get excited about the UP Web

When users are free to choose the algorithms themselves,
and when the app-developing users are rewarded for how well
they benefit other users rather than how well the benefit the profits
of the website, the UP Web will be able to eliminate some of the
unfortunate circumstances that plagues the current web.

In the following subsections, we will list some of the reasons
why to get excited about the UP Web as a user.


#### 1. Make it easier to limit your screen time

When you are in charge the algorithms that you use, you do not have to
choose algorithms that are optimized for maximizing your watch time and
engagement.

If you want to make it easier for yourself to limit your screen time,
you can thus simply choose algorithms that only shows you things
that are relevant to what you initially looked for, rather than always
trying to funnel you into a dopamine trap.


#### 2. Filter out inappropriate content

When algorithms are only optimized to maximize your engagement,
they are incentivized to push new content very quickly to a large group
of users. But by doing so, they also increase the risk of showing
inappropriate or damaging content to the users.

But when you are in charge of the algorithms that you use, you can make
sure that content is only shown to you once it has been past enough other
users first, who have been given enough of time to report the
content if it is inappropriate.  

And in case there is a shortage of users who volunteer to be among the
first ones to see new content, and to report it if it is inappropriate,
we will start to give out rewards to such users as a way of attracting
more.


#### 3. Avoid misinformation

When algorithms are only optimized to maximize engagement, they are
also not really incentivized to filter out content that spreads
misinformation, since that kind of content also only helps to increase
engagement. 

But when the algorithms are instead optimized to maximize user benefit,
content that clearly spreads misinformation can be filtered out, in the
same way as for inappropriate content.

Furthermore, when facts are disputed, we can make sure that the user is
warned about this. And we can even make sure to show list of fact-checking
user groups and/or third parties in such cases, along with
the scores for how these user groups and third parties have deemed the
veracity of the information.



#### 4. Suppress rude and nonconstructive posts and comments

Another downside of using existing web apps whose algorithms seek to
maximize user engagement is that this has the effect of boosting
negative discourse.
This is due to the fact that negative and disruptive posts
often attract more engagement than earnest and constructive ones.

Whenever you reply to a rude post or comment, even if you reply in
order to express your opposition to it,
the algorithms still see this as engagement,
and will try to boost the visibility of such content in the future,
for you and for other users.
Therefore, paradoxically, showing your opposition to a piece of content
actually helps that content.

Furthermore, since negative post and comments are boosted by the
algorithms in this way, users who wants more attention are thus
incentivized to create even more negative and disruptive content, leading
to a bad spiral effect.

However, when the algorithms are user-programmed, and are not
trying to optimize for engagement at all cost, it is a rather simple
matter to give the users the option to rate posts and comments on a
scale from being nonconstructive to being earnest, and to have the
algorithms strongly suppress the users that tends to be nonconstructive
in their posts and comments.


#### 5. Filter out AI slop and clickbait

The contemporary algorithms that only try to maximize watch time
and user engagement are also effectively blind to whether the given
piece of content is clickbait, or if it is AI slop, or in general if
it pretends to be something that it is not.

But with user-programmed algorithms, it is also a rather simple
matter to allow users to rate whether a given post is clickbait, or
AI generated, or otherwise insincere, which then allows the algorithms
to subsequently suppress that post.


#### 6. Control what data the algorithms collect

Another issue with contemporary web apps is that they are often not
very transparent about what data they collect about you.

But when each user can choose exactly which algorithms to use, the
they can also choose precisely what data should and should not be
collected about them.


#### 7. Enjoy a greater variety of possibilities

Last but not least, since the UP can draw on its entire user base for
coming up with new creative solutions and features, for the apps and
for the algorithms, it will no doubt lead to much greater variety of
possibilities for the users.

The world of open source already has a vast number of contributors,
collectively spending vast amounts of time and energy on open source
projects, despite often not getting paid at all for their contributions.
Thus, if the UP Web can attract even just a small fraction of all that
work and energy, it will not take long before the UP Web can offer
products that are on par with contemporary apps.

And from there, the UP Web can only continue to evolve,
drawing on the combined creativity of all its users, who can continue
to come up with new ideas for useful apps and features.




## How to get started

If you want to get started on making your first user-programmed apps,
go see the
[Tutorial pages](https://www.up-web.org/tutorials).


And if looking for inspiration, or just wanting to see what app
components other users have made so far, you can go to the
[Components page](https://www.up-web.org/entPath/1/1/em1.js;get/components).
(After having clicked on an element in this list,
you need to click 'View component' in order to see it rendered.)


There is also a
[Projects page](https://www.up-web.org/entPath/1/1/em1.js;get/projects)
where users can post and discuss ongoing projects relating to the
UP Web.
However, at this early stage of the website, we actually recommend
joining an UP Web forum on a more established SoMe website instead for
the time being,
at least while this Projects page is still under construction.
The currently available (official) forums are:

* *A list of external forum links will be inserted here soon.*

By all means, please join one or more of these external forums if you
are at all interested in keeping yourself up-to-date with the evolution
of the UP Web project.
And if you have any questions at all as a learner of this framework,
or if you want to discuss anything related to the UP Web,
these forums will also be a great way for you do so.


Once it becomes relevant for you, there is also a
[Contributions page](https://www.up-web.org/entPath/1/1/em1.js;get/contributions)
where you can log your contributions to the project.
Note that contributions do not need to be related to source code
only. They can also be things such as spreading awareness of the
project, etc.


And if you want to have a look at the fundamental source code
of the project, or perhaps want to help maintain and extend it at
some point, this is currently found at
[github.com/mjdamgaard/UP-Web-Project](https://github.com/mjdamgaard/UP-Web-Project).


But before you go anywhere, please note that this website is still
only a prototype at this stage. So please excuse all the rough edges
that you will find here and there.



<!-- If you want to get started on making your first user-programmed apps, go to the
[Tutorials](https://www.up-web.org/tutorials)
page.

And to see a list of the ongoing projects related to the UP Web, go see the
[Projects](https://www.up-web.org/entPath/1/1/em1.js;get/projects)
page.

You can also go to the
[Components](https://www.up-web.org/entPath/1/1/em1.js;get/components)
page to see some of the proof-of-concept app components that have been made so far. (After having clicked on an element in this list, you need to click 'View component' in order to see it rendered.)

And if you want to have a look at the fundamental source code of the project,
or perhaps want to help maintain and extend it at some point, this is currently found at
[github.com/mjdamgaard/UP-Web-Project](https://github.com/mjdamgaard/UP-Web-Project).

Once it becomes relevant for you, there is also a
[Contributions](https://www.up-web.org/entPath/1/1/em1.js;get/contributions)
page where you can log your contributions to the project. (Also feel free to contact up-web.org directly, if you want us to take note of a contribution of yours.) Note that contributions do not need to be related to source code only. They can also be things such as spreading awareness of the project, which will also be very much appreciated, indeed.

But before you go anywhere, please note that this website is still only a prototype at this stage. So please excuse all the rough edges that you will find here and there. -->


















<!-- 
### A distributed and decentralized open source network 
This project is open source, and copy-lefted, which means that anyone is free to fork the project if they want to, and is also free to set up their own service providers for the network.

In fact, the whole project aims to become a distributed and decentralized system in time, with a whole network of independent nodes that are programmed, by the users, to work together and create what we might then call the 'User-Programmable Web.'




## A React-like JS framework that runs all source code in a sandbox

### Basics
At the core if this technology is a special JS interpreter that runs all source code in a sandbox, with a different set of functions available when compared to regular JS, such that each accessible function is safe to be executed for all users.

Apart from a few functions that are built into the JS interpreter itself, most of the fundamental functions available, that are not user-defined ones, come from so-called 'developer libraries.' These libraries are imported dynamically by the user scripts, which means that there are no limit to the number of developer libraries that the given service provider might make available for its users.

Furthermore, users can also import functions and classes, etc., from other user-uploaded directories.

When a user wants to upload a new project, they can upload it as a whole directory at once. They will then become the admin of that directory, which means that they are also free to edit the files in that directory.



### Front-end React-like components
One particular developer library that is already available from the beginning is one that implements a React-like JS framework, where users can write React-like JSX components for the front end. This is how users are able to program new web apps for the website, and/or new components for existing web apps.

In fact, if you go and view the prototype at [up-web.org](https://www.up-web.org), almost everything you see on the site, apart from the top right user account menu, is programmed in this React-like framework. And any user will thus be able to program the same thing, and much more.

The users might even find that this alternative React-like framework is easier to use in some ways than regular React, since it removes a lot of boilerplate code that you would otherwise have to include in React, in particular when you want a component to be able to transmit signals to its ancestor components or descendant components.



### Back-end server modules
Users are furthermore able to create and upload back-end modules, to which the front-end components can connect in order to fetch or post data to the database. We will refer to such modules here as 'server modules' (SMs).

A server module (SM) is any JS module that is uploaded to a directory with the extension of '.sm.js'. For such modules, each function that is exported from the module is treated as part of the API of that SM, allowing clients to call these functions via a certain type of HTTP request.

When a called server module function (SMF) is executed this way, it automatically elevates the privileges of the execution environment such that the function is allowed to post data to the database (at least in the case of a POST request), and to fetch private data. Other server modules in other project directories will not be able to write directly to the same part of the database, nor read any of the private data stored there. So if a given SM wants to post data to a different SM in a different project directory, it will have to use the same exact API as the clients do.

A very keen reader might then ask: If users are supposed to be able to freely try out web apps and app components of other users, what is preventing those components from sending requests to any SM that they want and request it to delete or corrupt some of the user's data, or to fetch private data on behalf of the user, and then trick the user into posting this data again to another SM, where others are able read it?

The answer is by utilizing a system much like the Cross-Origin Resource Sharing (CORS) system used by HTTP, but where the "origin" of the request is not the domain of the website, but rather the path to the given component that sends the request. Any SMF that carries out such sensitive actions should thus make sure to first call a function that checks and authorizes the requesting component. And as long as these components are clear and explicit about the action that is about to happen, this should prevent users from accidentally deleting or publicizing any of their data.

The SMFs can also allow clients to override their CORS-like checks, namely if said clients have assigned special trust the requesting component. This means that old SMs can still remain in use, without having to continuously update their component whitelists whenever a part of the user base wants to use different front-end components to communicate with them.
 -->


<!--
## An outline of how to use the system

As mentioned, the prototype at [up-web.org](https://www.up-web.org) is currently still a few weeks from being ready to showcase. But let us try to give a quick overview of how that website will function in order to allow users to create web applications in a modular and collaborative way.

When a user has uploaded a project directory containing some app components that they want to make available for others, they can create a new entity in the database for each of these components. These entities will contain defining information about the component, including the internal URL for importing it into other scripts, as well as a description of it, and also preferably a link to a GitHub repository containing the source code. By using GitHub this way, it first of all means that the source code is backed up online. And it also allows users to identify themselves as authors of the code, and to choose the license for their source code. By choosing an open-source, copy-left license, it signals that other users are free to build upon your solutions and to use them in other projects.

<!-- Using GitHub this way also automatically gives us an online backup of the source code, which means that if a service provider somehow fails — maybe from being hacked, or maybe the user base loses trust in them — then user can easily just copy projects onto a new service provider in the network. Furthermore, the admins of a project directories will also be able to download backups of the public user data held in relational database tables, which means that this data can also be backed up and copied onto other service provider nodes in the network. - ->

When an entity representing a component is added to the database, the user will be able to navigate to a category of all 'App components' on the website, and submit the component entity to that category. Other users will then be able to view it and try it out, and to up-rate it among the existing components in the category.

This main category of 'App components' will thus initially provide a good way for users to share web applications with each other. But as the list grows, it will be necessary with subcategories as well. In order to get that, the website also allows users to submit entities representing subcategories as well, and to up-rate them for the given parent category, exactly in the same way that they are able to submit and up-rate members of the category. Examples of subcategories for the 'App components' category could be categories such as 'Social media apps,' or 'Games,' or 'UI utility components,' etc.

And of course, each of these subcategories can then again get their own subcategories, and so on, giving us a growing tree full of different kinds of components. With such a tree, users will be able to categorize their new solutions precisely, and others will be able to find these solutions easily, simply be going down the tree of categories until they find exactly the category of components that they are looking for.
-->




<!-- ## An "Everything Website"

### User-defined web pages
The 'App components' tree will be available on its own web page at [up-web.org](https://www.up-web.org), accessed from the header menu. But what about the home page of the website? Which component should be shown here?

Here we will actually also give the reins completely to the users, and have them decide what this home page should contain. The 'App components' tree thus ought to include a category specifically of 'Home pages.' And here we will simply choose the top-rated one in that category to show as the home page of the website.

It will thus be completely up to the users what the home page should look like, including what other pages it links to, and what web applications it links to. One might compare this to a wiki site such as Wikipedia, but where the pages can link not just to other article pages, but to any kind of page or web app, or any kind of component at all. This will thus essentially allow the users to build what we might call an "Everything Website," with the ability to contain any kind of application that the users want.



### Self-updating links and nested components

Furthermore, we will implement what we might refer to as 'variable links,' or 'self-updating links.' These are links that instead of leading to a constant component, does a similar thing as we do for the home page, namely to query for the top-rated component for a given category, and then link to that.

This first of all means that the author of a page or an app does not need to keep updating the links contained in the page/app continuously. Instead, by using one of the 'variable links,' the link will just always automatically lead to the best version of the given component that is available in the network, as rated by the users.

And we can even do the same thing for nested components, namely by implementing a component that automatically queries for the top-rated component for a given category and then renders that.

For instance, if the page is some Wikipedia-like article, say, about a person, the author of the article component is able to define a component category of 'Early life' sections for that person. And whenever some user writes/edits a better version of that section, as rated by the users, it will automatically replace the previous one. And the author can do this with any other section as well. So by using these 'variable components,' the whole article can thus become self-updating in this way in principle.


### User-tailored pages

And while this automatic updating of components will be very handy, it is not even the main reason that one might choose to use such variable components and links. An even more exciting reason to use these is that it allows users to get the version of the page/app that best suits their own individual preferences. The self-updating components are thus able to look at the specific user's preferences when it comes to what is the best component to show, or to link to.

For example, when it comes to Wikipedia-like articles, one user might generally prefer longer and more elaborate articles, and another user might generally prefer more brief and concise articles.

And for social media apps, some users might prefer a more keen and careful moderation that filters out undesired posts from the user's feed, while other users might prefer a less thorough moderation in general. And there might also be a big difference in what kind of posts each user is sensitive to.

Furthermore, even when it comes to the layout and theme of a given app or page, the variable components can allow users to get different versions. There is thus no limit, in principle, for how much each web app or web page can be tailored to any specific type of user.


### Decentralized algorithms

And when it comes to the algorithms used in e.g. feeds or search result of various web applications, the users can also be in complete charge of which algorithms they want to use.

Sure, any web application is free to use any specific algorithm that it wants. But unless there is a good reason for not choosing an algorithm with a high level of transparency and ability to be tailored specifically to the individual user's preferences, the users will likely just choose an alternative application instead where they have more agency over the algorithms.

This will hopefully usher in a new age of the Web where using an algorithm is not a quid pro quo, like how things are now: The algorithms collect personal data about you when you use them, often in a non-transparent way, and in return you get results that might be more relevant to you, if you are lucky (at least until the process of "enshittification" inevitable takes its toll).

But with this user-programmable system, the users can be in complete charge over the algorithms. They are the ones that program them, first of all. And each of them can be free to choose whichever algorithm that they want to use themselves.

Particularly, in terms of the user data that is fed to the algorithms, each user will be able to provide only the data that *they* want. And even if they don't want to provide any at all, this is also possible, as they can then instead just try to tweak the parameters of a given algorithm manually, in order to make them suit their preferences the best. No quid pro quo needed.





## Superusers and regular users

Obviously, not all users will be programmers that contribute source code to the network. Some users will of course just be using the apps of the network without contributing source code on their own. And that is perfectly fine.

The same is true when it comes to selecting which algorithm to use. Obviously, we cannot expect each individual user to go and select their preferred algorithms before being able to use the website. Instead we will simply select the most popular set of preferences as the default ones for each new user, and then make it easy for users to change these preferences whenever they want.



## GDPR and similar legal matters

In terms of things like GDPR, the hope is that the network will at some point achieve a legal status similar to the Word-Wide Web, where it is not the service providers that are liable for the contents of the user-made applications of the network.

But until that is achieved, [up-web.org](https://www.up-web.org) will simply reserve the right to delete any app, along with its data, that does not comply to GDPR, or does not comply to other terms of service. (But if using GitHub, your source code, and any backups of the public data that you have made for your app, will still be available there, and can possibly be moved to other service providers.)

And for apps that tries any sort of malicious behavior, such as phishing attempts, or attempts to make the users delete, corrupt, or involuntarily publicize their data, we will most likely also keep reserving the right to delete such apps for any foreseeable future. -->










<!--
  The two out-commented sections below are now a bit out-dated, but are not
  completely irrelevant, though.
-->

<!-- 
## Business model

In order to fund this open source project, we will include a 'Sponsors' page on the website, where sponsors can advertise themselves.

We will also accept individual donations from anyone interested in supporting the project.

And if the company does a good job of helping to start the UP Web, and helping to maintain the whole project, this will increase the likelihood of getting more sponsors and donors in the future.

So in short, the business model is to attract sponsors and donors by spending the money on helping the UP Web project along.

This money will first of all go paying the cost of running the servers, as well as to maintain the fundamental source code of the project. But it will also go towards rewarding the various users that contribute their own source code to the project.

The website might also at some point start to show ads in the margins of the webpages, but this is only a last resort if the cost of running the servers per user turns out to be greater than the donations and sponsorship money that the company can attract per user.  
 -->



<!--
## Business model

There are several different approaches that one could take in order to fund this open source project. And the one of the simplest ones would be to just have a 'Sponsors' page on the website(s), where sponsors can advertise themselves. The money that this would bring in could easily be enough to pay the costs of providing access to the databases needed for the project.


However, there is also a more elaborate approach that one might take, which can hopefully bring a lot more money to the project, while still eliminating the risk of enshittification that a purely capitalistic approach would normally entail.

This approach involves a (so far) hypothetical company model of a 'share-redistributing company' (SRC).


### A share-redistributing company

In short, an SRC is a company whose shares are slowly and continuously redistributed to the customers, namely by requiring that each purchase comes with an attachment of a small share in the company.
The shares are not given out for free, however. The company will generally increase the price accordingly, such that the customer pays for both the price of original product or service that they buy, as well as the price of the share that is attached to the purchase.

Additionally, an SRC generally prohibits the shares that have been redistributed this way to be traded[^1], thus ensuring that the majority of the company will eventually end up being owned by the customers.

[^1]: Exceptions can be made for customer shareholders that has reached an old enough age, allowing them to sell shares back to the company, which thus means that the customer shares can function as part of a pension plan.

What this does is thus essentially to force the customers to make a small, binding investment with each purchase, slowly buying out the original owners of the company.
Now, on the surface, being forced to make such an investment would not seem to be a benefit to the customer. Except for the fact that all other customers are equally forced to do the same thing. And by knowing that the majority of the shares will be taken over by the customers in a near future, each customer can then rest assured that the company will not take a turn for the worse, once the customer base has grown dependent on the company, and start trying to squeeze as much money and value out of the customers as they can get away with.

When the overlap between the shareholders and the customers has grown large enough, there is simply no real point in squeezing.


### Ad-watching end users as the primary customers

Of course, when talking about websites in particular, the customers are often not the actual end users, but rather the companies that buy ad space on the websites. However, we can always reinterpret the money coming from the ads as coming from the users instead, meaning that it is the users that watch the ads who earn the company shares.

A particular way that this could be achieved is to make sure that each ad comes with a code at the bottom, which can be redeemed by the user in order to prove that they have viewed the ad. And when it comes to video ads, typing in the code could even be how you skip the ad. When the ad plays, more and more of the code is revealed, meaning that the user might get a greater reward for watching more of the ad.

Each advertising company should then be able to determine the specifics of how and when the codes are shown, what they are worth when redeemed and how this reward might depend on user demographics, as well as how much the rewards diminish if the same user watches the same ad again within a short span of time.

And instead of requiring the advertising companies to pay up front, we can make a deal where they pay exactly the amount of money that has been redeemed by the users from watching their specific ads.

This way, we can essentially see it as the advertising companies paying the users who watch their ads, who then immediately pay that money to the SRC, granting them access to more content on the website, as well as rewarding them shares in the company.

And given that the advertising companies thus essentially buy the ad space directly from the users themselves, it makes sense to give the users complete freedom to choose the algorithm that should govern what ads are shown to them and when. This means that the advertising companies will be competing with each other to get the users to watch their ads, not least by choosing a competitive level of rewards for them.

The SRC itself does then not need to care about which ads are watched by the users, but only about the money that the users generate by doing so, and that this money is sufficient in regards to the amount of content that the user consumes on the website.
And of course, if a user just wants to pay the money directly themselves, rather than having to watch ads, that should also not matter to the SRC.


### A balance between capitalism and open source

By implementing this SRC, we can hopefully strike a perfect balance between capitalism and open source. It should be obvious that if this company grows large enough that it can rival current Web 2.0 websites, such as Facebook or YouTube for example, or even surpasses them, then there is a lot of money on the line for the investors, even despite the fact the they will not get to squeeze as much money out of the users in the long run as they would with e.g. an LLC.

This prospect will hopefully allow us to attract large investments early on, by what will become the initial shareholders of the SRC. The plan is then to immediately start rewarding the users that contribute source code to the UP Web, and preferably quite generously, such that we can attract even more open source developers.

Getting more developers early on means that the web applications that the UP Web offers will sooner be able to attract users. And more users means more excitement and more trust in the project, which might then further lead to more investments, and so on.

Now, in the beginning, it makes sense to just rely on rewarding open source contributions to the project. But after a time, it will also make sense to create a license that allows developers to dedicate their work specifically to the SRC in question, and not just to any fork of the UP Web project. And if they do so, the SRC might then give them greater rewards in return, as this helps create insurances for the investors that they will at some point be able to require the users to watch ads or pay money to access content.

However, when the company starts acquiring IP rights to the source code, it obviously also runs the risk of losing the interest that follows from being an open source alternative. And this could negatively affect the excitement and support of the open source developers, as well as that of the regular users. After all, if the company is just another capitalistic company similar to the existing options out there, what is the point of getting excited about it?

This is where the point of choosing an SRC as the company model comes into play. Hopefully, when the users know that all their contributed IPs will eventually end up being distributed widely among the user base, rather than being owned by a relatively small group of investors, they will still retain the excitement of taking part in the project.

So by using the SRC model, we might thus be able to retain the excitement of the users due to being an open source alternative to existing websites, while at the same time even being able to grant the monetary rewards to the source code contributors that they deserve.

-->